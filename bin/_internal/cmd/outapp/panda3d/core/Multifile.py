# encoding: utf-8
# module panda3d.core
# from C:\Users\leonm\PycharmProjects\leonsystem\venv\Lib\site-packages\panda3d\core.cp311-win_amd64.pyd
# by generator 1.147
# no doc

# imports
import dtoolconfig as __dtoolconfig
import enum as __enum


from .ReferenceCount import ReferenceCount

class Multifile(ReferenceCount):
    """
    /**
     * A file that contains a set of files.
     */
    """
    def addSignature(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        add_signature(const Multifile self, const Filename composite)
        add_signature(const Multifile self, const Filename composite, str password)
        add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * The chain filename may be empty if the certificate does not require an
         * authenticating certificate chain (e.g.  because it is self-signed).
         *
         * The specified private key must match the certificate, and the Multifile
         * must be open in read-write mode.  The private key is only used for
         * generating the signature; it is not written to the Multifile and cannot be
         * retrieved from the Multifile later.  (However, the certificate *can* be
         * retrieved from the Multifile later, to identify the entity that created the
         * signature.)
         *
         * This implicitly causes a repack() operation if one is needed.  Returns true
         * on success, false on failure.
         *
         * This flavor of add_signature() reads the certificate and private key from a
         * PEM-formatted file, for instance as generated by the openssl command.  If
         * the private key file is password-encrypted, the third parameter will be
         * used as the password to decrypt it.
         */
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * This flavor of add_signature() reads the certificate, private key, and
         * certificate chain from the same PEM-formatted file.  It takes the first
         * private key found as the intended key, and then uses the first certificate
         * found that matches that key as the signing certificate.  Any other
         * certificates in the file are taken to be part of the chain.
         */
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * The signature certificate is the first certificate on the CertChain object.
         * Any remaining certificates are support certificates to authenticate the
         * first one.
         *
         * The specified private key must match the certificate, and the Multifile
         * must be open in read-write mode.  The private key is only used for
         * generating the signature; it is not written to the Multifile and cannot be
         * retrieved from the Multifile later.  (However, the certificate *can* be
         * retrieved from the Multifile later, to identify the entity that created the
         * signature.)
         *
         * This implicitly causes a repack() operation if one is needed.  Returns true
         * on success, false on failure.
         */
        """
        pass

    def addSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        add_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)
        add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)
        
        /**
         * Adds a file on disk as a subfile to the Multifile.  The file named by
         * filename will be read and added to the Multifile at the next call to
         * flush().  If there already exists a subfile with the indicated name, it is
         * replaced without examining its contents (but see also update_subfile).
         *
         * Either Filename:::set_binary() or set_text() must have been called
         * previously to specify the nature of the source file.  If set_text() was
         * called, the text flag will be set on the subfile.
         *
         * Returns the subfile name on success (it might have been modified slightly),
         * or empty string on failure.
         */
        
        /**
         * Adds a file from a stream as a subfile to the Multifile.  The indicated
         * istream will be read and its contents added to the Multifile at the next
         * call to flush(). The file will be added as a binary subfile.
         *
         * Note that the istream must remain untouched and unused by any other code
         * until flush() is called.  At that time, the Multifile will read the entire
         * contents of the istream from the current file position to the end of the
         * file.  Subsequently, the Multifile will *not* close or delete the istream.
         * It is the caller's responsibility to ensure that the istream pointer does
         * not destruct during the lifetime of the Multifile.
         *
         * Returns the subfile name on success (it might have been modified slightly),
         * or empty string on failure.
         */
        """
        pass

    def add_signature(self, const_Multifile_self, const_Filename_composite): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        add_signature(const Multifile self, const Filename composite)
        add_signature(const Multifile self, const Filename composite, str password)
        add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * The chain filename may be empty if the certificate does not require an
         * authenticating certificate chain (e.g.  because it is self-signed).
         *
         * The specified private key must match the certificate, and the Multifile
         * must be open in read-write mode.  The private key is only used for
         * generating the signature; it is not written to the Multifile and cannot be
         * retrieved from the Multifile later.  (However, the certificate *can* be
         * retrieved from the Multifile later, to identify the entity that created the
         * signature.)
         *
         * This implicitly causes a repack() operation if one is needed.  Returns true
         * on success, false on failure.
         *
         * This flavor of add_signature() reads the certificate and private key from a
         * PEM-formatted file, for instance as generated by the openssl command.  If
         * the private key file is password-encrypted, the third parameter will be
         * used as the password to decrypt it.
         */
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * This flavor of add_signature() reads the certificate, private key, and
         * certificate chain from the same PEM-formatted file.  It takes the first
         * private key found as the intended key, and then uses the first certificate
         * found that matches that key as the signing certificate.  Any other
         * certificates in the file are taken to be part of the chain.
         */
        
        /**
         * Adds a new signature to the Multifile.  This signature associates the
         * indicated certificate with the current contents of the Multifile.  When the
         * Multifile is read later, the signature will still be present only if the
         * Multifile is unchanged; any subsequent changes to the Multifile will
         * automatically invalidate and remove the signature.
         *
         * The signature certificate is the first certificate on the CertChain object.
         * Any remaining certificates are support certificates to authenticate the
         * first one.
         *
         * The specified private key must match the certificate, and the Multifile
         * must be open in read-write mode.  The private key is only used for
         * generating the signature; it is not written to the Multifile and cannot be
         * retrieved from the Multifile later.  (However, the certificate *can* be
         * retrieved from the Multifile later, to identify the entity that created the
         * signature.)
         *
         * This implicitly causes a repack() operation if one is needed.  Returns true
         * on success, false on failure.
         */
        """
        pass

    def add_subfile(self, const_Multifile_self, str_subfile_name, const_Filename_filename, int_compression_level): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        add_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)
        add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)
        
        /**
         * Adds a file on disk as a subfile to the Multifile.  The file named by
         * filename will be read and added to the Multifile at the next call to
         * flush().  If there already exists a subfile with the indicated name, it is
         * replaced without examining its contents (but see also update_subfile).
         *
         * Either Filename:::set_binary() or set_text() must have been called
         * previously to specify the nature of the source file.  If set_text() was
         * called, the text flag will be set on the subfile.
         *
         * Returns the subfile name on success (it might have been modified slightly),
         * or empty string on failure.
         */
        
        /**
         * Adds a file from a stream as a subfile to the Multifile.  The indicated
         * istream will be read and its contents added to the Multifile at the next
         * call to flush(). The file will be added as a binary subfile.
         *
         * Note that the istream must remain untouched and unused by any other code
         * until flush() is called.  At that time, the Multifile will read the entire
         * contents of the istream from the current file position to the end of the
         * file.  Subsequently, the Multifile will *not* close or delete the istream.
         * It is the caller's responsibility to ensure that the istream pointer does
         * not destruct during the lifetime of the Multifile.
         *
         * Returns the subfile name on success (it might have been modified slightly),
         * or empty string on failure.
         */
        """
        pass

    def close(self, const_Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        close(const Multifile self)
        
        /**
         * Closes the Multifile if it is open.  All changes are flushed to disk, and
         * the file becomes invalid for further operations until the next call to
         * open().
         */
        """
        pass

    def closeReadSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        close_read_subfile(istream stream)
        
        /**
         * Closes a file opened by a previous call to open_read_subfile().  This
         * really just deletes the istream pointer, but it is recommended to use this
         * interface instead of deleting it explicitly, to help work around compiler
         * issues.
         */
        """
        pass

    def close_read_subfile(self, istream_stream): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        close_read_subfile(istream stream)
        
        /**
         * Closes a file opened by a previous call to open_read_subfile().  This
         * really just deletes the istream pointer, but it is recommended to use this
         * interface instead of deleting it explicitly, to help work around compiler
         * issues.
         */
        """
        pass

    def compareSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        compare_subfile(const Multifile self, int index, const Filename filename)
        
        /**
         * Performs a byte-for-byte comparison of the indicated file on disk with the
         * nth subfile.  Returns true if the files are equivalent, or false if they
         * are different (or the file is missing).
         *
         * If Filename::set_binary() or set_text() has already been called, it
         * specifies the nature of the source file.  If this is different from the
         * text flag of the subfile, the comparison will always return false.  If this
         * has not been specified, it will be set from the text flag of the subfile.
         */
        """
        pass

    def compare_subfile(self, const_Multifile_self, int_index, const_Filename_filename): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        compare_subfile(const Multifile self, int index, const Filename filename)
        
        /**
         * Performs a byte-for-byte comparison of the indicated file on disk with the
         * nth subfile.  Returns true if the files are equivalent, or false if they
         * are different (or the file is missing).
         *
         * If Filename::set_binary() or set_text() has already been called, it
         * specifies the nature of the source file.  If this is different from the
         * text flag of the subfile, the comparison will always return false.  If this
         * has not been specified, it will be set from the text flag of the subfile.
         */
        """
        pass

    def extractSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        extract_subfile(const Multifile self, int index, const Filename filename)
        
        /**
         * Extracts the nth subfile into a file with the given name.
         */
        """
        pass

    def extractSubfileTo(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        extract_subfile_to(const Multifile self, int index, ostream out)
        
        /**
         * Extracts the nth subfile to the indicated ostream.
         */
        """
        pass

    def extract_subfile(self, const_Multifile_self, int_index, const_Filename_filename): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        extract_subfile(const Multifile self, int index, const Filename filename)
        
        /**
         * Extracts the nth subfile into a file with the given name.
         */
        """
        pass

    def extract_subfile_to(self, const_Multifile_self, int_index, ostream_out): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        extract_subfile_to(const Multifile self, int index, ostream out)
        
        /**
         * Extracts the nth subfile to the indicated ostream.
         */
        """
        pass

    def findSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        find_subfile(Multifile self, str subfile_name)
        
        /**
         * Returns the index of the subfile with the indicated name, or -1 if the
         * named subfile is not within the Multifile.
         */
        """
        pass

    def find_subfile(self, Multifile_self, str_subfile_name): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        find_subfile(Multifile self, str subfile_name)
        
        /**
         * Returns the index of the subfile with the indicated name, or -1 if the
         * named subfile is not within the Multifile.
         */
        """
        pass

    def flush(self, const_Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        flush(const Multifile self)
        
        /**
         * Writes all contents of the Multifile to disk.  Until flush() is called,
         * add_subfile() and remove_subfile() do not actually do anything to disk.  At
         * this point, all of the recently-added subfiles are read and their contents
         * are added to the end of the Multifile, and the recently-removed subfiles
         * are marked gone from the Multifile.
         *
         * This may result in a suboptimal index.  To guarantee that the index is
         * written at the beginning of the file, call repack() instead of flush().
         *
         * It is not necessary to call flush() explicitly unless you are concerned
         * about reading the recently-added subfiles immediately.
         *
         * Returns true on success, false on failure.
         */
        """
        pass

    def getEncryptionAlgorithm(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_encryption_algorithm(Multifile self)
        
        /**
         * Returns the encryption algorithm that was specified by
         * set_encryption_algorithm().
         */
        """
        pass

    def getEncryptionFlag(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_encryption_flag(Multifile self)
        
        /**
         * Returns the flag indicating whether subsequently-added subfiles should be
         * encrypted before writing them to the multifile.  See set_encryption_flag().
         */
        """
        pass

    def getEncryptionIterationCount(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_encryption_iteration_count(Multifile self)
        
        /**
         * Returns the value that was specified by set_encryption_iteration_count().
         */
        """
        pass

    def getEncryptionKeyLength(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_encryption_key_length(Multifile self)
        
        /**
         * Returns the encryption key length, in bits, that was specified by
         * set_encryption_key_length().
         */
        """
        pass

    def getEncryptionPassword(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_encryption_password(Multifile self)
        
        /**
         * Returns the password that will be used to encrypt subfiles subsequently
         * added to the multifile.  See set_encryption_password().
         */
        """
        pass

    def getHeaderPrefix(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_header_prefix(Multifile self)
        
        /**
         * Returns the string that preceded the Multifile header on the file, if any.
         * See set_header_prefix().
         */
        """
        pass

    def getIndexEnd(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_index_end(Multifile self)
        
        /**
         * Returns the first byte that is guaranteed to follow any index byte already
         * written to disk in the Multifile.
         *
         * This number is largely meaningless in many cases, but if needs_repack() is
         * false, and the file is flushed, this will indicate the number of bytes in
         * the header + index.  Everything at this byte position and later will be
         * actual data.
         */
        """
        pass

    def getMagicNumber(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_magic_number()
        
        /**
         * Returns a string with the first n bytes written to a Multifile, to identify
         * it as a Multifile.
         */
        """
        pass

    def getMultifileName(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_multifile_name(Multifile self)
        
        /**
         * Returns the filename of the Multifile, if it is available.
         */
        """
        pass

    def getNumSignatures(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_num_signatures(Multifile self)
        
        /**
         * Returns the number of matching signatures found on the Multifile.  These
         * signatures may be iterated via get_signature() and related methods.
         *
         * A signature on this list is guaranteed to match the Multifile contents,
         * proving that the Multifile has been unmodified since the signature was
         * applied.  However, this does not guarantee that the certificate itself is
         * actually from who it says it is from; only that it matches the Multifile
         * contents.  See validate_signature_certificate() to authenticate a
         * particular certificate.
         */
        """
        pass

    def getNumSubfiles(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_num_subfiles(Multifile self)
        
        /**
         * Returns the number of subfiles within the Multifile.  The subfiles may be
         * accessed in alphabetical order by iterating through [0 ..
         * get_num_subfiles()).
         */
        """
        pass

    def getRecordTimestamp(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_record_timestamp(Multifile self)
        
        /**
         * Returns the flag indicating whether timestamps should be recorded within
         * the Multifile or not.  See set_record_timestamp().
         */
        """
        pass

    def getScaleFactor(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_scale_factor(Multifile self)
        
        /**
         * Returns the internal scale factor for this Multifile.  See
         * set_scale_factor().
         */
        """
        pass

    def getSignatureFriendlyName(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_signature_friendly_name(Multifile self, int n)
        
        /**
         * Returns a "friendly name" for the nth signature found on the Multifile.
         * This attempts to extract out the most meaningful part of the subject name.
         * It returns the emailAddress, if it is defined; otherwise, it returns the
         * commonName.
         *
         * See the comments in get_num_signatures().
         */
        """
        pass

    def getSignaturePublicKey(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_signature_public_key(Multifile self, int n)
        
        /**
         * Returns the public key used for the nth signature found on the Multifile.
         * This is encoded in DER form and returned as a string of hex digits.
         *
         * This can be used, in conjunction with the subject name (see
         * get_signature_subject_name()), to uniquely identify a particular
         * certificate and its subsequent reissues.  See the comments in
         * get_num_signatures().
         */
        """
        pass

    def getSignatureSubjectName(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_signature_subject_name(Multifile self, int n)
        
        /**
         * Returns the "subject name" for the nth signature found on the Multifile.
         * This is a string formatted according to RFC2253 that should more-or-less
         * identify a particular certificate; when paired with the public key (see
         * get_signature_public_key()), it can uniquely identify a certificate.  See
         * the comments in get_num_signatures().
         */
        """
        pass

    def getSubfileInternalLength(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_subfile_internal_length(Multifile self, int index)
        
        /**
         * Returns the number of bytes the indicated subfile consumes within the
         * archive.  For compressed subfiles, this will generally be smaller than
         * get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be
         * slightly different, for noncompressed and nonencrypted subfiles, it will be
         * equal.
         */
        """
        pass

    def getSubfileInternalStart(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_subfile_internal_start(Multifile self, int index)
        
        /**
         * Returns the starting byte position within the Multifile at which the
         * indicated subfile begins.  This may be used, with
         * get_subfile_internal_length(), for low-level access to the subfile, but
         * usually it is better to use open_read_subfile() instead (which
         * automatically decrypts and/or uncompresses the subfile data).
         */
        """
        pass

    def getSubfileLength(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_subfile_length(Multifile self, int index)
        
        /**
         * Returns the uncompressed data length of the nth subfile.  This might return
         * 0 if the subfile has recently been added and flush() has not yet been
         * called.
         */
        """
        pass

    def getSubfileName(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_subfile_name(Multifile self, int index)
        
        /**
         * Returns the name of the nth subfile.
         */
        """
        pass

    def getSubfileNames(self, *args, **kwargs): # real signature unknown
        pass

    def getSubfileTimestamp(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_subfile_timestamp(Multifile self, int index)
        
        /**
         * Returns the modification time of the nth subfile.  If this is called on an
         * older .mf file, which did not store individual timestamps in the file (or
         * if get_record_timestamp() is false), this will return the modification time
         * of the overall multifile.
         */
        """
        pass

    def getTimestamp(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        get_timestamp(Multifile self)
        
        /**
         * Returns the modification timestamp of the overall Multifile.  This
         * indicates the most recent date at which subfiles were added or removed from
         * the Multifile.  Note that it is logically possible for an individual
         * subfile to have a more recent timestamp than the overall timestamp.
         */
        """
        pass

    def get_encryption_algorithm(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_encryption_algorithm(Multifile self)
        
        /**
         * Returns the encryption algorithm that was specified by
         * set_encryption_algorithm().
         */
        """
        pass

    def get_encryption_flag(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_encryption_flag(Multifile self)
        
        /**
         * Returns the flag indicating whether subsequently-added subfiles should be
         * encrypted before writing them to the multifile.  See set_encryption_flag().
         */
        """
        pass

    def get_encryption_iteration_count(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_encryption_iteration_count(Multifile self)
        
        /**
         * Returns the value that was specified by set_encryption_iteration_count().
         */
        """
        pass

    def get_encryption_key_length(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_encryption_key_length(Multifile self)
        
        /**
         * Returns the encryption key length, in bits, that was specified by
         * set_encryption_key_length().
         */
        """
        pass

    def get_encryption_password(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_encryption_password(Multifile self)
        
        /**
         * Returns the password that will be used to encrypt subfiles subsequently
         * added to the multifile.  See set_encryption_password().
         */
        """
        pass

    def get_header_prefix(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_header_prefix(Multifile self)
        
        /**
         * Returns the string that preceded the Multifile header on the file, if any.
         * See set_header_prefix().
         */
        """
        pass

    def get_index_end(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_index_end(Multifile self)
        
        /**
         * Returns the first byte that is guaranteed to follow any index byte already
         * written to disk in the Multifile.
         *
         * This number is largely meaningless in many cases, but if needs_repack() is
         * false, and the file is flushed, this will indicate the number of bytes in
         * the header + index.  Everything at this byte position and later will be
         * actual data.
         */
        """
        pass

    def get_magic_number(self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_magic_number()
        
        /**
         * Returns a string with the first n bytes written to a Multifile, to identify
         * it as a Multifile.
         */
        """
        pass

    def get_multifile_name(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_multifile_name(Multifile self)
        
        /**
         * Returns the filename of the Multifile, if it is available.
         */
        """
        pass

    def get_num_signatures(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_num_signatures(Multifile self)
        
        /**
         * Returns the number of matching signatures found on the Multifile.  These
         * signatures may be iterated via get_signature() and related methods.
         *
         * A signature on this list is guaranteed to match the Multifile contents,
         * proving that the Multifile has been unmodified since the signature was
         * applied.  However, this does not guarantee that the certificate itself is
         * actually from who it says it is from; only that it matches the Multifile
         * contents.  See validate_signature_certificate() to authenticate a
         * particular certificate.
         */
        """
        pass

    def get_num_subfiles(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_num_subfiles(Multifile self)
        
        /**
         * Returns the number of subfiles within the Multifile.  The subfiles may be
         * accessed in alphabetical order by iterating through [0 ..
         * get_num_subfiles()).
         */
        """
        pass

    def get_record_timestamp(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_record_timestamp(Multifile self)
        
        /**
         * Returns the flag indicating whether timestamps should be recorded within
         * the Multifile or not.  See set_record_timestamp().
         */
        """
        pass

    def get_scale_factor(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_scale_factor(Multifile self)
        
        /**
         * Returns the internal scale factor for this Multifile.  See
         * set_scale_factor().
         */
        """
        pass

    def get_signature_friendly_name(self, Multifile_self, int_n): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_signature_friendly_name(Multifile self, int n)
        
        /**
         * Returns a "friendly name" for the nth signature found on the Multifile.
         * This attempts to extract out the most meaningful part of the subject name.
         * It returns the emailAddress, if it is defined; otherwise, it returns the
         * commonName.
         *
         * See the comments in get_num_signatures().
         */
        """
        pass

    def get_signature_public_key(self, Multifile_self, int_n): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_signature_public_key(Multifile self, int n)
        
        /**
         * Returns the public key used for the nth signature found on the Multifile.
         * This is encoded in DER form and returned as a string of hex digits.
         *
         * This can be used, in conjunction with the subject name (see
         * get_signature_subject_name()), to uniquely identify a particular
         * certificate and its subsequent reissues.  See the comments in
         * get_num_signatures().
         */
        """
        pass

    def get_signature_subject_name(self, Multifile_self, int_n): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_signature_subject_name(Multifile self, int n)
        
        /**
         * Returns the "subject name" for the nth signature found on the Multifile.
         * This is a string formatted according to RFC2253 that should more-or-less
         * identify a particular certificate; when paired with the public key (see
         * get_signature_public_key()), it can uniquely identify a certificate.  See
         * the comments in get_num_signatures().
         */
        """
        pass

    def get_subfile_internal_length(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_subfile_internal_length(Multifile self, int index)
        
        /**
         * Returns the number of bytes the indicated subfile consumes within the
         * archive.  For compressed subfiles, this will generally be smaller than
         * get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be
         * slightly different, for noncompressed and nonencrypted subfiles, it will be
         * equal.
         */
        """
        pass

    def get_subfile_internal_start(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_subfile_internal_start(Multifile self, int index)
        
        /**
         * Returns the starting byte position within the Multifile at which the
         * indicated subfile begins.  This may be used, with
         * get_subfile_internal_length(), for low-level access to the subfile, but
         * usually it is better to use open_read_subfile() instead (which
         * automatically decrypts and/or uncompresses the subfile data).
         */
        """
        pass

    def get_subfile_length(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_subfile_length(Multifile self, int index)
        
        /**
         * Returns the uncompressed data length of the nth subfile.  This might return
         * 0 if the subfile has recently been added and flush() has not yet been
         * called.
         */
        """
        pass

    def get_subfile_name(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_subfile_name(Multifile self, int index)
        
        /**
         * Returns the name of the nth subfile.
         */
        """
        pass

    def get_subfile_names(self, *args, **kwargs): # real signature unknown
        pass

    def get_subfile_timestamp(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_subfile_timestamp(Multifile self, int index)
        
        /**
         * Returns the modification time of the nth subfile.  If this is called on an
         * older .mf file, which did not store individual timestamps in the file (or
         * if get_record_timestamp() is false), this will return the modification time
         * of the overall multifile.
         */
        """
        pass

    def get_timestamp(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        get_timestamp(Multifile self)
        
        /**
         * Returns the modification timestamp of the overall Multifile.  This
         * indicates the most recent date at which subfiles were added or removed from
         * the Multifile.  Note that it is logically possible for an individual
         * subfile to have a more recent timestamp than the overall timestamp.
         */
        """
        pass

    def hasDirectory(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        has_directory(Multifile self, str subfile_name)
        
        /**
         * Returns true if the indicated subfile name is the directory prefix to one
         * or more files within the Multifile.  That is, the Multifile contains at
         * least one file named "subfile_name/...".
         */
        """
        pass

    def has_directory(self, Multifile_self, str_subfile_name): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        has_directory(Multifile self, str subfile_name)
        
        /**
         * Returns true if the indicated subfile name is the directory prefix to one
         * or more files within the Multifile.  That is, the Multifile contains at
         * least one file named "subfile_name/...".
         */
        """
        pass

    def isReadValid(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        is_read_valid(Multifile self)
        
        /**
         * Returns true if the Multifile has been opened for read mode and there have
         * been no errors, and individual Subfile contents may be extracted.
         */
        """
        pass

    def isSubfileCompressed(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        is_subfile_compressed(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile has been compressed when stored
         * within the archive, false otherwise.
         */
        """
        pass

    def isSubfileEncrypted(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        is_subfile_encrypted(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile has been encrypted when stored within
         * the archive, false otherwise.
         */
        """
        pass

    def isSubfileText(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        is_subfile_text(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile represents text data, or false if it
         * represents binary data.  If the file is text data, it may have been
         * processed by end-of-line conversion when it was added.  (But the actual
         * bits in the multifile will represent the standard Unix end-of-line
         * convention, e.g.  \n instead of \r\n.)
         */
        """
        pass

    def isWriteValid(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        is_write_valid(Multifile self)
        
        /**
         * Returns true if the Multifile has been opened for write mode and there have
         * been no errors, and Subfiles may be added or removed from the Multifile.
         */
        """
        pass

    def is_read_valid(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        is_read_valid(Multifile self)
        
        /**
         * Returns true if the Multifile has been opened for read mode and there have
         * been no errors, and individual Subfile contents may be extracted.
         */
        """
        pass

    def is_subfile_compressed(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        is_subfile_compressed(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile has been compressed when stored
         * within the archive, false otherwise.
         */
        """
        pass

    def is_subfile_encrypted(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        is_subfile_encrypted(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile has been encrypted when stored within
         * the archive, false otherwise.
         */
        """
        pass

    def is_subfile_text(self, Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        is_subfile_text(Multifile self, int index)
        
        /**
         * Returns true if the indicated subfile represents text data, or false if it
         * represents binary data.  If the file is text data, it may have been
         * processed by end-of-line conversion when it was added.  (But the actual
         * bits in the multifile will represent the standard Unix end-of-line
         * convention, e.g.  \n instead of \r\n.)
         */
        """
        pass

    def is_write_valid(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        is_write_valid(Multifile self)
        
        /**
         * Returns true if the Multifile has been opened for write mode and there have
         * been no errors, and Subfiles may be added or removed from the Multifile.
         */
        """
        pass

    def ls(self, Multifile_self, ostream_out): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        ls(Multifile self, ostream out)
        
        /**
         * Shows a list of all subfiles within the Multifile.
         */
        """
        pass

    def needsRepack(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        needs_repack(Multifile self)
        
        /**
         * Returns true if the Multifile index is suboptimal and should be repacked.
         * Call repack() to achieve this.
         */
        """
        pass

    def needs_repack(self, Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        needs_repack(Multifile self)
        
        /**
         * Returns true if the Multifile index is suboptimal and should be repacked.
         * Call repack() to achieve this.
         */
        """
        pass

    def openRead(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, long offset)
        
        /**
         * Opens the named Multifile on disk for reading.  The Multifile index is read
         * in, and the list of subfiles becomes available; individual subfiles may
         * then be extracted or read, but the list of subfiles may not be modified.
         *
         * Also see the version of open_read() which accepts an istream.  Returns true
         * on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for reading using an istream.  There must be
         * seek functionality via seekg() and tellg() on the istream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def openReadSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        open_read_subfile(const Multifile self, int index)
        
        /**
         * Returns an istream that may be used to read the indicated subfile.  You may
         * seek() within this istream to your heart's content; even though it will be
         * a reference to the already-opened pfstream of the Multifile itself, byte 0
         * appears to be the beginning of the subfile and EOF appears to be the end of
         * the subfile.
         *
         * The returned istream will have been allocated via new; you should pass the
         * pointer to close_read_subfile() when you are finished with it to delete it
         * and release its resources.
         *
         * Any future calls to repack() or close() (or the Multifile destructor) will
         * invalidate all currently open subfile pointers.
         *
         * The return value will be NULL if the stream cannot be opened for some
         * reason.
         */
        
        /**
         * This variant of open_read_subfile() is used internally only, and accepts a
         * pointer to the internal Subfile object, which is assumed to be valid and
         * written to the multifile.
         */
        """
        pass

    def openReadWrite(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)
        
        /**
         * Opens the named Multifile on disk for reading and writing.  If there
         * already exists a file by that name, its index is read.  Subfiles may be
         * added or removed, and the resulting changes will be written to the named
         * file.
         *
         * Also see the version of open_read_write() which accepts an iostream.
         * Returns true on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for reading and writing using an iostream.
         * There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
         * the iostream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def openWrite(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)
        
        /**
         * Opens the named Multifile on disk for writing.  If there already exists a
         * file by that name, it is truncated.  The Multifile is then prepared for
         * accepting a brand new set of subfiles, which will be written to the
         * indicated filename.  Individual subfiles may not be extracted or read.
         *
         * Also see the version of open_write() which accepts an ostream.  Returns
         * true on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for writing using an ostream.  There must be
         * seek functionality via seekp() and tellp() on the pstream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def open_read(self, const_Multifile_self, IStreamWrapper_multifile_stream, bool_owns_pointer, long_offset): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, long offset)
        
        /**
         * Opens the named Multifile on disk for reading.  The Multifile index is read
         * in, and the list of subfiles becomes available; individual subfiles may
         * then be extracted or read, but the list of subfiles may not be modified.
         *
         * Also see the version of open_read() which accepts an istream.  Returns true
         * on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for reading using an istream.  There must be
         * seek functionality via seekg() and tellg() on the istream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def open_read_subfile(self, const_Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        open_read_subfile(const Multifile self, int index)
        
        /**
         * Returns an istream that may be used to read the indicated subfile.  You may
         * seek() within this istream to your heart's content; even though it will be
         * a reference to the already-opened pfstream of the Multifile itself, byte 0
         * appears to be the beginning of the subfile and EOF appears to be the end of
         * the subfile.
         *
         * The returned istream will have been allocated via new; you should pass the
         * pointer to close_read_subfile() when you are finished with it to delete it
         * and release its resources.
         *
         * Any future calls to repack() or close() (or the Multifile destructor) will
         * invalidate all currently open subfile pointers.
         *
         * The return value will be NULL if the stream cannot be opened for some
         * reason.
         */
        
        /**
         * This variant of open_read_subfile() is used internally only, and accepts a
         * pointer to the internal Subfile object, which is assumed to be valid and
         * written to the multifile.
         */
        """
        pass

    def open_read_write(self, const_Multifile_self, iostream_multifile_stream, bool_owns_pointer): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)
        
        /**
         * Opens the named Multifile on disk for reading and writing.  If there
         * already exists a file by that name, its index is read.  Subfiles may be
         * added or removed, and the resulting changes will be written to the named
         * file.
         *
         * Also see the version of open_read_write() which accepts an iostream.
         * Returns true on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for reading and writing using an iostream.
         * There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
         * the iostream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def open_write(self, const_Multifile_self, ostream_multifile_stream, bool_owns_pointer): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)
        
        /**
         * Opens the named Multifile on disk for writing.  If there already exists a
         * file by that name, it is truncated.  The Multifile is then prepared for
         * accepting a brand new set of subfiles, which will be written to the
         * indicated filename.  Individual subfiles may not be extracted or read.
         *
         * Also see the version of open_write() which accepts an ostream.  Returns
         * true on success, false on failure.
         */
        
        /**
         * Opens an anonymous Multifile for writing using an ostream.  There must be
         * seek functionality via seekp() and tellp() on the pstream.
         *
         * If owns_pointer is true, then the Multifile assumes ownership of the stream
         * pointer and will delete it when the multifile is closed, including if this
         * function returns false.
         */
        """
        pass

    def output(self, Multifile_self, ostream_out): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        output(Multifile self, ostream out)
        
        /**
         *
         */
        """
        pass

    def printSignatureCertificate(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        print_signature_certificate(Multifile self, int n, ostream out)
        
        /**
         * Writes the certificate for the nth signature, in user-readable verbose
         * form, to the indicated stream.  See the comments in get_num_signatures().
         */
        """
        pass

    def print_signature_certificate(self, Multifile_self, int_n, ostream_out): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        print_signature_certificate(Multifile self, int n, ostream out)
        
        /**
         * Writes the certificate for the nth signature, in user-readable verbose
         * form, to the indicated stream.  See the comments in get_num_signatures().
         */
        """
        pass

    def readSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        read_subfile(const Multifile self, int index)
        
        /**
         * Returns a vector_uchar that contains the entire contents of the indicated
         * subfile.
         */
        
        /**
         * Fills a string with the entire contents of the indicated subfile.
         */
        
        /**
         * Fills a pvector with the entire contents of the indicated subfile.
         */
        """
        pass

    def read_subfile(self, const_Multifile_self, int_index): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        read_subfile(const Multifile self, int index)
        
        /**
         * Returns a vector_uchar that contains the entire contents of the indicated
         * subfile.
         */
        
        /**
         * Fills a string with the entire contents of the indicated subfile.
         */
        
        /**
         * Fills a pvector with the entire contents of the indicated subfile.
         */
        """
        pass

    def removeSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        remove_subfile(const Multifile self, str subfile_name)
        remove_subfile(const Multifile self, int index)
        
        /**
         * Removes the named subfile from the Multifile, if it exists; returns true if
         * successfully removed, or false if it did not exist in the first place.  The
         * file will not actually be removed from the disk until the next call to
         * flush().
         *
         * Note that this does not actually remove the data from the indicated
         * subfile; it simply removes it from the index.  The Multifile will not be
         * reduced in size after this operation, until the next call to repack().
         */
        
        /**
         * Removes the nth subfile from the Multifile.  This will cause all subsequent
         * index numbers to decrease by one.  The file will not actually be removed
         * from the disk until the next call to flush().
         *
         * Note that this does not actually remove the data from the indicated
         * subfile; it simply removes it from the index.  The Multifile will not be
         * reduced in size after this operation, until the next call to repack().
         */
        """
        pass

    def remove_subfile(self, const_Multifile_self, str_subfile_name): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        remove_subfile(const Multifile self, str subfile_name)
        remove_subfile(const Multifile self, int index)
        
        /**
         * Removes the named subfile from the Multifile, if it exists; returns true if
         * successfully removed, or false if it did not exist in the first place.  The
         * file will not actually be removed from the disk until the next call to
         * flush().
         *
         * Note that this does not actually remove the data from the indicated
         * subfile; it simply removes it from the index.  The Multifile will not be
         * reduced in size after this operation, until the next call to repack().
         */
        
        /**
         * Removes the nth subfile from the Multifile.  This will cause all subsequent
         * index numbers to decrease by one.  The file will not actually be removed
         * from the disk until the next call to flush().
         *
         * Note that this does not actually remove the data from the indicated
         * subfile; it simply removes it from the index.  The Multifile will not be
         * reduced in size after this operation, until the next call to repack().
         */
        """
        pass

    def repack(self, const_Multifile_self): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        repack(const Multifile self)
        
        /**
         * Forces a complete rewrite of the Multifile and all of its contents, so that
         * its index will appear at the beginning of the file with all of the subfiles
         * listed in alphabetical order.  This is considered optimal for reading, and
         * is the standard configuration; but it is not essential to do this.
         *
         * It is only valid to call this if the Multifile was opened using
         * open_read_write() and an explicit filename, rather than an iostream.  Also,
         * we must have write permission to the directory containing the Multifile.
         *
         * Returns true on success, false on failure.
         */
        """
        pass

    def setEncryptionAlgorithm(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_encryption_algorithm(const Multifile self, str encryption_algorithm)
        
        /**
         * Specifies the encryption algorithm that should be used for future calls to
         * add_subfile().  The default is whatever is specified by the encryption-
         * algorithm config variable.  The complete set of available algorithms is
         * defined by the current version of OpenSSL.
         *
         * If an invalid algorithm is specified, there is no immediate error return
         * code, but flush() will fail and the file will be invalid.
         *
         * It is possible to apply a different encryption algorithm to different
         * files, and unlike the password, this does not interfere with mounting the
         * multifile via VFS.  Changing this value may cause an implicit call to
         * flush().
         */
        """
        pass

    def setEncryptionFlag(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_encryption_flag(const Multifile self, bool flag)
        
        /**
         * Sets the flag indicating whether subsequently-added subfiles should be
         * encrypted before writing them to the multifile.  If true, subfiles will be
         * encrypted; if false (the default), they will be written without encryption.
         *
         * When true, subfiles will be encrypted with the password specified by
         * set_encryption_password().  It is possible to apply a different password to
         * different files, but the resulting file can't be mounted via VFS.
         */
        """
        pass

    def setEncryptionIterationCount(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)
        
        /**
         * Specifies the number of times to repeatedly hash the key before writing it
         * to the stream in future calls to add_subfile().  Its purpose is to make it
         * computationally more expensive for an attacker to search the key space
         * exhaustively.  This should be a multiple of 1,000 and should not exceed
         * about 65 million; the value 0 indicates just one application of the hashing
         * algorithm.
         *
         * The default is whatever is specified by the multifile-encryption-iteration-
         * count config variable.
         *
         * It is possible to apply a different iteration count to different files, and
         * unlike the password, this does not interfere with mounting the multifile
         * via VFS.  Changing this value causes an implicit call to flush().
         */
        """
        pass

    def setEncryptionKeyLength(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_encryption_key_length(const Multifile self, int encryption_key_length)
        
        /**
         * Specifies the length of the key, in bits, that should be used to encrypt
         * the stream in future calls to add_subfile().  The default is whatever is
         * specified by the encryption-key-length config variable.
         *
         * If an invalid key_length for the chosen algorithm is specified, there is no
         * immediate error return code, but flush() will fail and the file will be
         * invalid.
         *
         * It is possible to apply a different key length to different files, and
         * unlike the password, this does not interfere with mounting the multifile
         * via VFS. Changing this value may cause an implicit call to flush().
         */
        """
        pass

    def setEncryptionPassword(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_encryption_password(const Multifile self, str encryption_password)
        
        /**
         * Specifies the password that will be used to encrypt subfiles subsequently
         * added to the multifile, if the encryption flag is also set true (see
         * set_encryption_flag()).
         *
         * It is possible to apply a different password to different files, but the
         * resulting file can't be mounted via VFS.  Changing this value may cause an
         * implicit call to flush().
         */
        """
        pass

    def setHeaderPrefix(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_header_prefix(const Multifile self, str header_prefix)
        
        /**
         * Sets the string which is written to the Multifile before the Multifile
         * header.  This string must begin with a hash mark and end with a newline
         * character; and if it includes embedded newline characters, each one must be
         * followed by a hash mark.  If these conditions are not initially true, the
         * string will be modified as necessary to make it so.
         *
         * This is primarily useful as a simple hack to allow p3d applications to be
         * run directly from the command line on Unix-like systems.
         *
         * The return value is true if successful, or false on failure (for instance,
         * because the header prefix violates the above rules).
         */
        """
        pass

    def setMultifileName(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_multifile_name(const Multifile self, const Filename multifile_name)
        
        /**
         * Replaces the filename of the Multifile.  This is primarily used for
         * documentation purposes only; changing this name does not open the indicated
         * file.  See open_read() or open_write() for that.
         */
        """
        pass

    def setRecordTimestamp(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_record_timestamp(const Multifile self, bool record_timestamp)
        
        /**
         * Sets the flag indicating whether timestamps should be recorded within the
         * Multifile or not.  The default is true, indicating the Multifile will
         * record timestamps for the overall file and also for each subfile.
         *
         * If this is false, the Multifile will not record timestamps internally.  In
         * this case, the return value from get_timestamp() or get_subfile_timestamp()
         * will be estimations.
         *
         * You may want to set this false to minimize the bitwise difference between
         * independently-generated Multifiles.
         */
        """
        pass

    def setScaleFactor(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_scale_factor(const Multifile self, int scale_factor)
        
        /**
         * Changes the internal scale factor for this Multifile.
         *
         * This is normally 1, but it may be set to any arbitrary value (greater than
         * zero) to support Multifile archives that exceed 4GB, if necessary.
         * (Individual subfiles may still not exceed 4GB.)
         *
         * All addresses within the file are rounded up to the next multiple of
         * _scale_factor, and zeros are written to the file to fill the resulting
         * gaps.  Then the address is divided by _scale_factor and written out as a
         * 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB
         * files, 3 supports 12GB files, etc.
         *
         * Calling this function on an already-existing Multifile will have no
         * immediate effect until a future call to repack() or close() (or until the
         * Multifile is destructed).
         */
        """
        pass

    def setTimestamp(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        set_timestamp(const Multifile self, int timestamp)
        
        /**
         * Changes the overall mudification timestamp of the multifile.  Note that this
         * will be reset to the current time every time you modify a subfile.
         * Only set this if you know what you are doing!
         */
        """
        pass

    def set_encryption_algorithm(self, const_Multifile_self, str_encryption_algorithm): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_encryption_algorithm(const Multifile self, str encryption_algorithm)
        
        /**
         * Specifies the encryption algorithm that should be used for future calls to
         * add_subfile().  The default is whatever is specified by the encryption-
         * algorithm config variable.  The complete set of available algorithms is
         * defined by the current version of OpenSSL.
         *
         * If an invalid algorithm is specified, there is no immediate error return
         * code, but flush() will fail and the file will be invalid.
         *
         * It is possible to apply a different encryption algorithm to different
         * files, and unlike the password, this does not interfere with mounting the
         * multifile via VFS.  Changing this value may cause an implicit call to
         * flush().
         */
        """
        pass

    def set_encryption_flag(self, const_Multifile_self, bool_flag): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_encryption_flag(const Multifile self, bool flag)
        
        /**
         * Sets the flag indicating whether subsequently-added subfiles should be
         * encrypted before writing them to the multifile.  If true, subfiles will be
         * encrypted; if false (the default), they will be written without encryption.
         *
         * When true, subfiles will be encrypted with the password specified by
         * set_encryption_password().  It is possible to apply a different password to
         * different files, but the resulting file can't be mounted via VFS.
         */
        """
        pass

    def set_encryption_iteration_count(self, const_Multifile_self, int_encryption_iteration_count): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)
        
        /**
         * Specifies the number of times to repeatedly hash the key before writing it
         * to the stream in future calls to add_subfile().  Its purpose is to make it
         * computationally more expensive for an attacker to search the key space
         * exhaustively.  This should be a multiple of 1,000 and should not exceed
         * about 65 million; the value 0 indicates just one application of the hashing
         * algorithm.
         *
         * The default is whatever is specified by the multifile-encryption-iteration-
         * count config variable.
         *
         * It is possible to apply a different iteration count to different files, and
         * unlike the password, this does not interfere with mounting the multifile
         * via VFS.  Changing this value causes an implicit call to flush().
         */
        """
        pass

    def set_encryption_key_length(self, const_Multifile_self, int_encryption_key_length): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_encryption_key_length(const Multifile self, int encryption_key_length)
        
        /**
         * Specifies the length of the key, in bits, that should be used to encrypt
         * the stream in future calls to add_subfile().  The default is whatever is
         * specified by the encryption-key-length config variable.
         *
         * If an invalid key_length for the chosen algorithm is specified, there is no
         * immediate error return code, but flush() will fail and the file will be
         * invalid.
         *
         * It is possible to apply a different key length to different files, and
         * unlike the password, this does not interfere with mounting the multifile
         * via VFS. Changing this value may cause an implicit call to flush().
         */
        """
        pass

    def set_encryption_password(self, const_Multifile_self, str_encryption_password): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_encryption_password(const Multifile self, str encryption_password)
        
        /**
         * Specifies the password that will be used to encrypt subfiles subsequently
         * added to the multifile, if the encryption flag is also set true (see
         * set_encryption_flag()).
         *
         * It is possible to apply a different password to different files, but the
         * resulting file can't be mounted via VFS.  Changing this value may cause an
         * implicit call to flush().
         */
        """
        pass

    def set_header_prefix(self, const_Multifile_self, str_header_prefix): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_header_prefix(const Multifile self, str header_prefix)
        
        /**
         * Sets the string which is written to the Multifile before the Multifile
         * header.  This string must begin with a hash mark and end with a newline
         * character; and if it includes embedded newline characters, each one must be
         * followed by a hash mark.  If these conditions are not initially true, the
         * string will be modified as necessary to make it so.
         *
         * This is primarily useful as a simple hack to allow p3d applications to be
         * run directly from the command line on Unix-like systems.
         *
         * The return value is true if successful, or false on failure (for instance,
         * because the header prefix violates the above rules).
         */
        """
        pass

    def set_multifile_name(self, const_Multifile_self, const_Filename_multifile_name): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_multifile_name(const Multifile self, const Filename multifile_name)
        
        /**
         * Replaces the filename of the Multifile.  This is primarily used for
         * documentation purposes only; changing this name does not open the indicated
         * file.  See open_read() or open_write() for that.
         */
        """
        pass

    def set_record_timestamp(self, const_Multifile_self, bool_record_timestamp): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_record_timestamp(const Multifile self, bool record_timestamp)
        
        /**
         * Sets the flag indicating whether timestamps should be recorded within the
         * Multifile or not.  The default is true, indicating the Multifile will
         * record timestamps for the overall file and also for each subfile.
         *
         * If this is false, the Multifile will not record timestamps internally.  In
         * this case, the return value from get_timestamp() or get_subfile_timestamp()
         * will be estimations.
         *
         * You may want to set this false to minimize the bitwise difference between
         * independently-generated Multifiles.
         */
        """
        pass

    def set_scale_factor(self, const_Multifile_self, int_scale_factor): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_scale_factor(const Multifile self, int scale_factor)
        
        /**
         * Changes the internal scale factor for this Multifile.
         *
         * This is normally 1, but it may be set to any arbitrary value (greater than
         * zero) to support Multifile archives that exceed 4GB, if necessary.
         * (Individual subfiles may still not exceed 4GB.)
         *
         * All addresses within the file are rounded up to the next multiple of
         * _scale_factor, and zeros are written to the file to fill the resulting
         * gaps.  Then the address is divided by _scale_factor and written out as a
         * 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB
         * files, 3 supports 12GB files, etc.
         *
         * Calling this function on an already-existing Multifile will have no
         * immediate effect until a future call to repack() or close() (or until the
         * Multifile is destructed).
         */
        """
        pass

    def set_timestamp(self, const_Multifile_self, int_timestamp): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        set_timestamp(const Multifile self, int timestamp)
        
        /**
         * Changes the overall mudification timestamp of the multifile.  Note that this
         * will be reset to the current time every time you modify a subfile.
         * Only set this if you know what you are doing!
         */
        """
        pass

    def updateSubfile(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)
        
        /**
         * Adds a file on disk to the subfile.  If a subfile already exists with the
         * same name, its contents are compared byte-for-byte to the disk file, and it
         * is replaced only if it is different; otherwise, the multifile is left
         * unchanged.
         *
         * Either Filename:::set_binary() or set_text() must have been called
         * previously to specify the nature of the source file.  If set_text() was
         * called, the text flag will be set on the subfile.
         */
        """
        pass

    def update_subfile(self, const_Multifile_self, str_subfile_name, const_Filename_filename, int_compression_level): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)
        
        /**
         * Adds a file on disk to the subfile.  If a subfile already exists with the
         * same name, its contents are compared byte-for-byte to the disk file, and it
         * is replaced only if it is different; otherwise, the multifile is left
         * unchanged.
         *
         * Either Filename:::set_binary() or set_text() must have been called
         * previously to specify the nature of the source file.  If set_text() was
         * called, the text flag will be set on the subfile.
         */
        """
        pass

    def validateSignatureCertificate(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        validate_signature_certificate(Multifile self, int n)
        
        /**
         * Checks that the certificate used for the nth signature is a valid,
         * authorized certificate with some known certificate authority.  Returns 0 if
         * it is valid, -1 if there is some error, or the corresponding OpenSSL error
         * code if it is invalid, out-of-date, or self-signed.
         */
        """
        pass

    def validate_signature_certificate(self, Multifile_self, int_n): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        validate_signature_certificate(Multifile self, int n)
        
        /**
         * Checks that the certificate used for the nth signature is a valid,
         * authorized certificate with some known certificate authority.  Returns 0 if
         * it is valid, -1 if there is some error, or the corresponding OpenSSL error
         * code if it is invalid, out-of-date, or self-signed.
         */
        """
        pass

    def writeSignatureCertificate(self, *args, **kwargs): # real signature unknown
        """
        C++ Interface:
        write_signature_certificate(Multifile self, int n, ostream out)
        
        /**
         * Writes the certificate for the nth signature, in PEM form, to the indicated
         * stream.  See the comments in get_num_signatures().
         */
        """
        pass

    def write_signature_certificate(self, Multifile_self, int_n, ostream_out): # real signature unknown; restored from __doc__
        """
        C++ Interface:
        write_signature_certificate(Multifile self, int n, ostream out)
        
        /**
         * Writes the certificate for the nth signature, in PEM form, to the indicated
         * stream.  See the comments in get_num_signatures().
         */
        """
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __repr__(self, *args, **kwargs): # real signature unknown
        """ Return repr(self). """
        pass

    def __str__(self, *args, **kwargs): # real signature unknown
        """ Return str(self). """
        pass

    DtoolClassDict = {
        'DtoolClassDict': '<value is a self-reference, replaced by this string>',
        '__doc__': '/**\n * A file that contains a set of files.\n */',
        '__init__': None, # (!) real value is "<slot wrapper '__init__' of 'panda3d.core.Multifile' objects>"
        '__new__': None, # (!) real value is '<built-in method __new__ of type object at 0x00007FFCFE278F10>'
        '__repr__': None, # (!) real value is "<slot wrapper '__repr__' of 'panda3d.core.Multifile' objects>"
        '__str__': None, # (!) real value is "<slot wrapper '__str__' of 'panda3d.core.Multifile' objects>"
        'addSignature': None, # (!) real value is "<method 'addSignature' of 'panda3d.core.Multifile' objects>"
        'addSubfile': None, # (!) real value is "<method 'addSubfile' of 'panda3d.core.Multifile' objects>"
        'add_signature': None, # (!) real value is "<method 'add_signature' of 'panda3d.core.Multifile' objects>"
        'add_subfile': None, # (!) real value is "<method 'add_subfile' of 'panda3d.core.Multifile' objects>"
        'close': None, # (!) real value is "<method 'close' of 'panda3d.core.Multifile' objects>"
        'closeReadSubfile': None, # (!) real value is '<staticmethod(<built-in method closeReadSubfile of type object at 0x00007FFCFE278F10>)>'
        'close_read_subfile': None, # (!) real value is '<staticmethod(<built-in method close_read_subfile of type object at 0x00007FFCFE278F10>)>'
        'compareSubfile': None, # (!) real value is "<method 'compareSubfile' of 'panda3d.core.Multifile' objects>"
        'compare_subfile': None, # (!) real value is "<method 'compare_subfile' of 'panda3d.core.Multifile' objects>"
        'extractSubfile': None, # (!) real value is "<method 'extractSubfile' of 'panda3d.core.Multifile' objects>"
        'extractSubfileTo': None, # (!) real value is "<method 'extractSubfileTo' of 'panda3d.core.Multifile' objects>"
        'extract_subfile': None, # (!) real value is "<method 'extract_subfile' of 'panda3d.core.Multifile' objects>"
        'extract_subfile_to': None, # (!) real value is "<method 'extract_subfile_to' of 'panda3d.core.Multifile' objects>"
        'findSubfile': None, # (!) real value is "<method 'findSubfile' of 'panda3d.core.Multifile' objects>"
        'find_subfile': None, # (!) real value is "<method 'find_subfile' of 'panda3d.core.Multifile' objects>"
        'flush': None, # (!) real value is "<method 'flush' of 'panda3d.core.Multifile' objects>"
        'getEncryptionAlgorithm': None, # (!) real value is "<method 'getEncryptionAlgorithm' of 'panda3d.core.Multifile' objects>"
        'getEncryptionFlag': None, # (!) real value is "<method 'getEncryptionFlag' of 'panda3d.core.Multifile' objects>"
        'getEncryptionIterationCount': None, # (!) real value is "<method 'getEncryptionIterationCount' of 'panda3d.core.Multifile' objects>"
        'getEncryptionKeyLength': None, # (!) real value is "<method 'getEncryptionKeyLength' of 'panda3d.core.Multifile' objects>"
        'getEncryptionPassword': None, # (!) real value is "<method 'getEncryptionPassword' of 'panda3d.core.Multifile' objects>"
        'getHeaderPrefix': None, # (!) real value is "<method 'getHeaderPrefix' of 'panda3d.core.Multifile' objects>"
        'getIndexEnd': None, # (!) real value is "<method 'getIndexEnd' of 'panda3d.core.Multifile' objects>"
        'getMagicNumber': None, # (!) real value is '<staticmethod(<built-in method getMagicNumber of type object at 0x00007FFCFE278F10>)>'
        'getMultifileName': None, # (!) real value is "<method 'getMultifileName' of 'panda3d.core.Multifile' objects>"
        'getNumSignatures': None, # (!) real value is "<method 'getNumSignatures' of 'panda3d.core.Multifile' objects>"
        'getNumSubfiles': None, # (!) real value is "<method 'getNumSubfiles' of 'panda3d.core.Multifile' objects>"
        'getRecordTimestamp': None, # (!) real value is "<method 'getRecordTimestamp' of 'panda3d.core.Multifile' objects>"
        'getScaleFactor': None, # (!) real value is "<method 'getScaleFactor' of 'panda3d.core.Multifile' objects>"
        'getSignatureFriendlyName': None, # (!) real value is "<method 'getSignatureFriendlyName' of 'panda3d.core.Multifile' objects>"
        'getSignaturePublicKey': None, # (!) real value is "<method 'getSignaturePublicKey' of 'panda3d.core.Multifile' objects>"
        'getSignatureSubjectName': None, # (!) real value is "<method 'getSignatureSubjectName' of 'panda3d.core.Multifile' objects>"
        'getSubfileInternalLength': None, # (!) real value is "<method 'getSubfileInternalLength' of 'panda3d.core.Multifile' objects>"
        'getSubfileInternalStart': None, # (!) real value is "<method 'getSubfileInternalStart' of 'panda3d.core.Multifile' objects>"
        'getSubfileLength': None, # (!) real value is "<method 'getSubfileLength' of 'panda3d.core.Multifile' objects>"
        'getSubfileName': None, # (!) real value is "<method 'getSubfileName' of 'panda3d.core.Multifile' objects>"
        'getSubfileNames': None, # (!) real value is "<method 'getSubfileNames' of 'panda3d.core.Multifile' objects>"
        'getSubfileTimestamp': None, # (!) real value is "<method 'getSubfileTimestamp' of 'panda3d.core.Multifile' objects>"
        'getTimestamp': None, # (!) real value is "<method 'getTimestamp' of 'panda3d.core.Multifile' objects>"
        'get_encryption_algorithm': None, # (!) real value is "<method 'get_encryption_algorithm' of 'panda3d.core.Multifile' objects>"
        'get_encryption_flag': None, # (!) real value is "<method 'get_encryption_flag' of 'panda3d.core.Multifile' objects>"
        'get_encryption_iteration_count': None, # (!) real value is "<method 'get_encryption_iteration_count' of 'panda3d.core.Multifile' objects>"
        'get_encryption_key_length': None, # (!) real value is "<method 'get_encryption_key_length' of 'panda3d.core.Multifile' objects>"
        'get_encryption_password': None, # (!) real value is "<method 'get_encryption_password' of 'panda3d.core.Multifile' objects>"
        'get_header_prefix': None, # (!) real value is "<method 'get_header_prefix' of 'panda3d.core.Multifile' objects>"
        'get_index_end': None, # (!) real value is "<method 'get_index_end' of 'panda3d.core.Multifile' objects>"
        'get_magic_number': None, # (!) real value is '<staticmethod(<built-in method get_magic_number of type object at 0x00007FFCFE278F10>)>'
        'get_multifile_name': None, # (!) real value is "<method 'get_multifile_name' of 'panda3d.core.Multifile' objects>"
        'get_num_signatures': None, # (!) real value is "<method 'get_num_signatures' of 'panda3d.core.Multifile' objects>"
        'get_num_subfiles': None, # (!) real value is "<method 'get_num_subfiles' of 'panda3d.core.Multifile' objects>"
        'get_record_timestamp': None, # (!) real value is "<method 'get_record_timestamp' of 'panda3d.core.Multifile' objects>"
        'get_scale_factor': None, # (!) real value is "<method 'get_scale_factor' of 'panda3d.core.Multifile' objects>"
        'get_signature_friendly_name': None, # (!) real value is "<method 'get_signature_friendly_name' of 'panda3d.core.Multifile' objects>"
        'get_signature_public_key': None, # (!) real value is "<method 'get_signature_public_key' of 'panda3d.core.Multifile' objects>"
        'get_signature_subject_name': None, # (!) real value is "<method 'get_signature_subject_name' of 'panda3d.core.Multifile' objects>"
        'get_subfile_internal_length': None, # (!) real value is "<method 'get_subfile_internal_length' of 'panda3d.core.Multifile' objects>"
        'get_subfile_internal_start': None, # (!) real value is "<method 'get_subfile_internal_start' of 'panda3d.core.Multifile' objects>"
        'get_subfile_length': None, # (!) real value is "<method 'get_subfile_length' of 'panda3d.core.Multifile' objects>"
        'get_subfile_name': None, # (!) real value is "<method 'get_subfile_name' of 'panda3d.core.Multifile' objects>"
        'get_subfile_names': None, # (!) real value is "<method 'get_subfile_names' of 'panda3d.core.Multifile' objects>"
        'get_subfile_timestamp': None, # (!) real value is "<method 'get_subfile_timestamp' of 'panda3d.core.Multifile' objects>"
        'get_timestamp': None, # (!) real value is "<method 'get_timestamp' of 'panda3d.core.Multifile' objects>"
        'hasDirectory': None, # (!) real value is "<method 'hasDirectory' of 'panda3d.core.Multifile' objects>"
        'has_directory': None, # (!) real value is "<method 'has_directory' of 'panda3d.core.Multifile' objects>"
        'isReadValid': None, # (!) real value is "<method 'isReadValid' of 'panda3d.core.Multifile' objects>"
        'isSubfileCompressed': None, # (!) real value is "<method 'isSubfileCompressed' of 'panda3d.core.Multifile' objects>"
        'isSubfileEncrypted': None, # (!) real value is "<method 'isSubfileEncrypted' of 'panda3d.core.Multifile' objects>"
        'isSubfileText': None, # (!) real value is "<method 'isSubfileText' of 'panda3d.core.Multifile' objects>"
        'isWriteValid': None, # (!) real value is "<method 'isWriteValid' of 'panda3d.core.Multifile' objects>"
        'is_read_valid': None, # (!) real value is "<method 'is_read_valid' of 'panda3d.core.Multifile' objects>"
        'is_subfile_compressed': None, # (!) real value is "<method 'is_subfile_compressed' of 'panda3d.core.Multifile' objects>"
        'is_subfile_encrypted': None, # (!) real value is "<method 'is_subfile_encrypted' of 'panda3d.core.Multifile' objects>"
        'is_subfile_text': None, # (!) real value is "<method 'is_subfile_text' of 'panda3d.core.Multifile' objects>"
        'is_write_valid': None, # (!) real value is "<method 'is_write_valid' of 'panda3d.core.Multifile' objects>"
        'ls': None, # (!) real value is "<method 'ls' of 'panda3d.core.Multifile' objects>"
        'magic_number': None, # (!) real value is "<attribute 'magic_number' of 'panda3d.core.Multifile'>"
        'needsRepack': None, # (!) real value is "<method 'needsRepack' of 'panda3d.core.Multifile' objects>"
        'needs_repack': None, # (!) real value is "<method 'needs_repack' of 'panda3d.core.Multifile' objects>"
        'openRead': None, # (!) real value is "<method 'openRead' of 'panda3d.core.Multifile' objects>"
        'openReadSubfile': None, # (!) real value is "<method 'openReadSubfile' of 'panda3d.core.Multifile' objects>"
        'openReadWrite': None, # (!) real value is "<method 'openReadWrite' of 'panda3d.core.Multifile' objects>"
        'openWrite': None, # (!) real value is "<method 'openWrite' of 'panda3d.core.Multifile' objects>"
        'open_read': None, # (!) real value is "<method 'open_read' of 'panda3d.core.Multifile' objects>"
        'open_read_subfile': None, # (!) real value is "<method 'open_read_subfile' of 'panda3d.core.Multifile' objects>"
        'open_read_write': None, # (!) real value is "<method 'open_read_write' of 'panda3d.core.Multifile' objects>"
        'open_write': None, # (!) real value is "<method 'open_write' of 'panda3d.core.Multifile' objects>"
        'output': None, # (!) real value is "<method 'output' of 'panda3d.core.Multifile' objects>"
        'printSignatureCertificate': None, # (!) real value is "<method 'printSignatureCertificate' of 'panda3d.core.Multifile' objects>"
        'print_signature_certificate': None, # (!) real value is "<method 'print_signature_certificate' of 'panda3d.core.Multifile' objects>"
        'readSubfile': None, # (!) real value is "<method 'readSubfile' of 'panda3d.core.Multifile' objects>"
        'read_subfile': None, # (!) real value is "<method 'read_subfile' of 'panda3d.core.Multifile' objects>"
        'removeSubfile': None, # (!) real value is "<method 'removeSubfile' of 'panda3d.core.Multifile' objects>"
        'remove_subfile': None, # (!) real value is "<method 'remove_subfile' of 'panda3d.core.Multifile' objects>"
        'repack': None, # (!) real value is "<method 'repack' of 'panda3d.core.Multifile' objects>"
        'setEncryptionAlgorithm': None, # (!) real value is "<method 'setEncryptionAlgorithm' of 'panda3d.core.Multifile' objects>"
        'setEncryptionFlag': None, # (!) real value is "<method 'setEncryptionFlag' of 'panda3d.core.Multifile' objects>"
        'setEncryptionIterationCount': None, # (!) real value is "<method 'setEncryptionIterationCount' of 'panda3d.core.Multifile' objects>"
        'setEncryptionKeyLength': None, # (!) real value is "<method 'setEncryptionKeyLength' of 'panda3d.core.Multifile' objects>"
        'setEncryptionPassword': None, # (!) real value is "<method 'setEncryptionPassword' of 'panda3d.core.Multifile' objects>"
        'setHeaderPrefix': None, # (!) real value is "<method 'setHeaderPrefix' of 'panda3d.core.Multifile' objects>"
        'setMultifileName': None, # (!) real value is "<method 'setMultifileName' of 'panda3d.core.Multifile' objects>"
        'setRecordTimestamp': None, # (!) real value is "<method 'setRecordTimestamp' of 'panda3d.core.Multifile' objects>"
        'setScaleFactor': None, # (!) real value is "<method 'setScaleFactor' of 'panda3d.core.Multifile' objects>"
        'setTimestamp': None, # (!) real value is "<method 'setTimestamp' of 'panda3d.core.Multifile' objects>"
        'set_encryption_algorithm': None, # (!) real value is "<method 'set_encryption_algorithm' of 'panda3d.core.Multifile' objects>"
        'set_encryption_flag': None, # (!) real value is "<method 'set_encryption_flag' of 'panda3d.core.Multifile' objects>"
        'set_encryption_iteration_count': None, # (!) real value is "<method 'set_encryption_iteration_count' of 'panda3d.core.Multifile' objects>"
        'set_encryption_key_length': None, # (!) real value is "<method 'set_encryption_key_length' of 'panda3d.core.Multifile' objects>"
        'set_encryption_password': None, # (!) real value is "<method 'set_encryption_password' of 'panda3d.core.Multifile' objects>"
        'set_header_prefix': None, # (!) real value is "<method 'set_header_prefix' of 'panda3d.core.Multifile' objects>"
        'set_multifile_name': None, # (!) real value is "<method 'set_multifile_name' of 'panda3d.core.Multifile' objects>"
        'set_record_timestamp': None, # (!) real value is "<method 'set_record_timestamp' of 'panda3d.core.Multifile' objects>"
        'set_scale_factor': None, # (!) real value is "<method 'set_scale_factor' of 'panda3d.core.Multifile' objects>"
        'set_timestamp': None, # (!) real value is "<method 'set_timestamp' of 'panda3d.core.Multifile' objects>"
        'updateSubfile': None, # (!) real value is "<method 'updateSubfile' of 'panda3d.core.Multifile' objects>"
        'update_subfile': None, # (!) real value is "<method 'update_subfile' of 'panda3d.core.Multifile' objects>"
        'validateSignatureCertificate': None, # (!) real value is "<method 'validateSignatureCertificate' of 'panda3d.core.Multifile' objects>"
        'validate_signature_certificate': None, # (!) real value is "<method 'validate_signature_certificate' of 'panda3d.core.Multifile' objects>"
        'writeSignatureCertificate': None, # (!) real value is "<method 'writeSignatureCertificate' of 'panda3d.core.Multifile' objects>"
        'write_signature_certificate': None, # (!) real value is "<method 'write_signature_certificate' of 'panda3d.core.Multifile' objects>"
    }
    magic_number = 'pmf\x00\n\r'


